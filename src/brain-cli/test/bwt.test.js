"use strict";

const { describe, it, before, after, beforeEach } = require("node:test");
const assert = require("node:assert/strict");
const fs = require("fs");
const path = require("path");
const os = require("os");
const { BWTEngine } = require("../src/bwt");
const { readJsonl, safeReadJson, calculateHashFromString } = require("../src/utils");

// 테스트용 Brain/ 디렉토리를 매 테스트마다 신규 생성
let testRoot;

function setupBrain() {
  testRoot = fs.mkdtempSync(path.join(os.tmpdir(), "brain-bwt-test-"));

  // 폴더 구조 생성
  const dirs = [
    "00_user", "10_projects", "20_agents",
    "30_topics", "90_index", "99_policy"
  ];
  for (const d of dirs) {
    fs.mkdirSync(path.join(testRoot, d), { recursive: true });
  }

  // 최소 인덱스 파일 생성
  fs.writeFileSync(path.join(testRoot, "90_index", "records.jsonl"), "", "utf-8");

  fs.writeFileSync(path.join(testRoot, "90_index", "tags.json"), JSON.stringify({
    version: "1.0",
    axes: ["domain", "intent"],
    domain: { values: ["memory", "auth"], synonyms: {}, banned: [] },
    intent: { values: ["retrieval", "decision"], synonyms: {}, banned: [] }
  }, null, 2), "utf-8");

  fs.writeFileSync(path.join(testRoot, "90_index", "folderRegistry.json"), JSON.stringify({
    version: "1.0",
    folders: [
      { path: "00_user/", scopeType: "user", autoCreate: false },
      { path: "10_projects/", scopeType: "project", autoCreate: false },
      { path: "20_agents/", scopeType: "agent", autoCreate: false },
      { path: "30_topics/", scopeType: "topic", autoCreate: true },
      { path: "90_index/", scopeType: null, autoCreate: false },
      { path: "99_policy/", scopeType: null, autoCreate: false }
    ]
  }, null, 2), "utf-8");

  fs.writeFileSync(path.join(testRoot, "90_index", "manifest.json"), JSON.stringify({
    version: "1.0",
    brainRoot: "Brain",
    updatedAt: new Date().toISOString(),
    summary: { totalFiles: 0, byCategory: { policy: 0, user: 0, project: 0, agent: 0, topic: 0, index: 0 } },
    files: []
  }, null, 2), "utf-8");

  fs.writeFileSync(path.join(testRoot, "90_index", "records_digest.txt"),
    "# Brain records_digest.txt\n# Format: recordId | title | summary | tags | status\n# Auto-generated by brain-cli BWT. Do not edit manually.\n",
    "utf-8"
  );

  // brainPolicy.md (최소)
  fs.writeFileSync(path.join(testRoot, "99_policy", "brainPolicy.md"),
    "# Brain 운영 정책\n",
    "utf-8"
  );
}

function teardownBrain() {
  if (testRoot && fs.existsSync(testRoot)) {
    fs.rmSync(testRoot, { recursive: true, force: true });
  }
}

// --- 테스트 ---

describe("BWT Happy Path: create", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("문서 + 레코드를 정상 생성하고 인덱스를 갱신해야 한다", () => {
    const engine = new BWTEngine(testRoot);
    const intent = {
      action: "create",
      sourceRef: "30_topics/test-topic/notes.md",
      content: "# 테스트 노트\n\n이것은 BWT 테스트입니다.",
      record: {
        scopeType: "topic",
        scopeId: "test-topic",
        type: "note",
        title: "테스트 노트",
        summary: "BWT 테스트용 노트",
        tags: ["domain/memory", "intent/retrieval"],
        sourceType: "candidate"
      }
    };

    const result = engine.execute(intent);

    // 성공 확인
    assert.equal(result.success, true);
    assert.ok(result.recordId);
    assert.match(result.recordId, /^rec_topic_test-topic_\d{8}_0001$/);

    // 문서 파일 생성 확인
    const docPath = path.join(testRoot, "30_topics", "test-topic", "notes.md");
    assert.ok(fs.existsSync(docPath));
    assert.equal(fs.readFileSync(docPath, "utf-8"), intent.content);

    // records.jsonl 갱신 확인
    const records = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(records.length, 1);
    assert.equal(records[0].recordId, result.recordId);
    assert.equal(records[0].title, "테스트 노트");
    assert.equal(records[0].status, "active");
    assert.ok(records[0].contentHash.startsWith("sha256:"));

    // manifest.json 갱신 확인
    const manifest = JSON.parse(fs.readFileSync(
      path.join(testRoot, "90_index", "manifest.json"), "utf-8"
    ));
    assert.equal(manifest.files.length, 1);
    assert.equal(manifest.files[0].path, "30_topics/test-topic/notes.md");
    assert.equal(manifest.summary.totalFiles, 1);

    // records_digest.txt 갱신 확인
    const digest = fs.readFileSync(
      path.join(testRoot, "90_index", "records_digest.txt"), "utf-8"
    );
    assert.ok(digest.includes(result.recordId));
    assert.ok(digest.includes("테스트 노트"));

    // .tmp 잔류 없음
    const indexFiles = fs.readdirSync(path.join(testRoot, "90_index"));
    assert.equal(indexFiles.filter(f => f.endsWith(".tmp")).length, 0);

    // .bak 잔류 없음
    assert.equal(indexFiles.filter(f => f.endsWith(".bak")).length, 0);
  });
});

describe("BWT: update", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("기존 레코드를 update하면 필드가 갱신되어야 한다", () => {
    const engine = new BWTEngine(testRoot);

    // 먼저 create
    const createResult = engine.execute({
      action: "create",
      sourceRef: "30_topics/upd/notes.md",
      content: "원본 내용",
      record: {
        scopeType: "topic",
        scopeId: "upd",
        type: "note",
        title: "원본",
        summary: "원본 요약",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });
    assert.equal(createResult.success, true);

    // update
    const engine2 = new BWTEngine(testRoot);
    const updateResult = engine2.execute({
      action: "update",
      recordId: createResult.recordId,
      sourceRef: "30_topics/upd/notes.md",
      content: "수정된 내용",
      record: {
        title: "수정됨",
        summary: "수정된 요약"
      }
    });
    assert.equal(updateResult.success, true);

    // 검증
    const records = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(records.length, 1);
    assert.equal(records[0].title, "수정됨");
    assert.equal(records[0].summary, "수정된 요약");

    const doc = fs.readFileSync(path.join(testRoot, "30_topics", "upd", "notes.md"), "utf-8");
    assert.equal(doc, "수정된 내용");
  });
});

describe("BWT: deprecate", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("레코드를 deprecate하면 status가 deprecated로 변경되어야 한다", () => {
    const engine = new BWTEngine(testRoot);

    const createResult = engine.execute({
      action: "create",
      sourceRef: "30_topics/dep/notes.md",
      content: "내용",
      record: {
        scopeType: "topic",
        scopeId: "dep",
        type: "note",
        title: "삭제될 노트",
        summary: "요약",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });
    assert.equal(createResult.success, true);

    const engine2 = new BWTEngine(testRoot);
    const depResult = engine2.execute({
      action: "deprecate",
      recordId: createResult.recordId,
      replacedBy: "obsolete",
      deprecationReason: "테스트 목적"
    });
    assert.equal(depResult.success, true);

    const records = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(records[0].status, "deprecated");
    assert.equal(records[0].replacedBy, "obsolete");
    assert.equal(records[0].deprecationReason, "테스트 목적");
  });
});

describe("BWT: delete", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("레코드를 delete하면 records.jsonl에서 제거되어야 한다", () => {
    const engine = new BWTEngine(testRoot);

    const createResult = engine.execute({
      action: "create",
      sourceRef: "30_topics/del/notes.md",
      content: "삭제 테스트",
      record: {
        scopeType: "topic",
        scopeId: "del",
        type: "note",
        title: "삭제 노트",
        summary: "삭제 예정",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });
    assert.equal(createResult.success, true);

    const engine2 = new BWTEngine(testRoot);
    const delResult = engine2.execute({
      action: "delete",
      recordId: createResult.recordId
    });
    assert.equal(delResult.success, true);

    const records = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(records.length, 0);
  });
});

describe("BWT Rollback: validate 실패 시 원본 복구", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("validate 실패 시 .tmp가 삭제되고 원본이 보존되어야 한다", () => {
    // 먼저 정상 레코드 1개 생성
    const engine = new BWTEngine(testRoot);
    const createResult = engine.execute({
      action: "create",
      sourceRef: "30_topics/rb/notes.md",
      content: "정상 내용",
      record: {
        scopeType: "topic",
        scopeId: "rb",
        type: "note",
        title: "정상 노트",
        summary: "요약",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });
    assert.equal(createResult.success, true);

    // 원본 records.jsonl 스냅샷
    const originalRecords = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(originalRecords.length, 1);

    // 잘못된 Intent로 실패 유도 (존재하지 않는 recordId를 update)
    const engine2 = new BWTEngine(testRoot);
    const failResult = engine2.execute({
      action: "update",
      recordId: "rec_topic_nonexistent_20260101_9999",
      content: "잘못된 업데이트"
    });
    assert.equal(failResult.success, false);

    // 원본 보존 확인
    const afterRecords = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(afterRecords.length, 1);
    assert.equal(afterRecords[0].recordId, createResult.recordId);

    // .tmp 잔류 없음
    const indexFiles = fs.readdirSync(path.join(testRoot, "90_index"));
    assert.equal(indexFiles.filter(f => f.endsWith(".tmp")).length, 0);

    // .bak 잔류 없음
    assert.equal(indexFiles.filter(f => f.endsWith(".bak")).length, 0);
  });
});

describe("BWT: 잔류 .tmp 감지", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("인덱스에 .tmp 파일이 있으면 BWT를 거부해야 한다", () => {
    // .tmp 파일 수동 생성
    fs.writeFileSync(
      path.join(testRoot, "90_index", "records.jsonl.tmp"),
      "잔류 데이터",
      "utf-8"
    );

    const engine = new BWTEngine(testRoot);
    const result = engine.execute({
      action: "create",
      sourceRef: "30_topics/tmp/notes.md",
      content: "내용",
      record: {
        scopeType: "topic",
        scopeId: "tmp",
        type: "note",
        title: "제목",
        summary: "요약",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });

    assert.equal(result.success, false);
    assert.equal(result.report.step, 0);
    assert.ok(result.report.message.includes("잔류 .tmp"));

    // 정리
    fs.unlinkSync(path.join(testRoot, "90_index", "records.jsonl.tmp"));
  });
});

describe("BWT: Intent 검증 실패", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("잘못된 action이면 실패해야 한다", () => {
    const engine = new BWTEngine(testRoot);
    const result = engine.execute({
      action: "invalid_action",
      record: {
        scopeType: "topic",
        scopeId: "x",
        type: "note",
        title: "t",
        sourceType: "candidate"
      }
    });
    assert.equal(result.success, false);
    assert.equal(result.report.step, 1);
  });

  it("create에서 record 누락이면 실패해야 한다", () => {
    const engine = new BWTEngine(testRoot);
    const result = engine.execute({
      action: "create"
    });
    assert.equal(result.success, false);
    assert.equal(result.report.step, 1);
  });
});

describe("BWT: rollback이 미리 등록된 tmpFiles를 정리해야 한다", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("write 실패 시에도 tmpFiles에 등록된 .tmp가 정리되어야 한다", () => {
    const engine = new BWTEngine(testRoot);

    // 수동으로 tmpFiles에 경로 등록 + .tmp 파일 생성 (write 중간 실패 시뮬레이션)
    const fakeTmpPath = path.join(testRoot, "90_index", "records.jsonl.tmp");
    fs.writeFileSync(fakeTmpPath, "부분 작성된 데이터", "utf-8");
    engine.tmpFiles.push(fakeTmpPath);

    // bakFiles도 설정 (원본 백업 시뮬레이션)
    const originalPath = path.join(testRoot, "90_index", "records.jsonl");
    const originalContent = fs.readFileSync(originalPath, "utf-8");
    const bakPath = originalPath + ".bak";
    fs.copyFileSync(originalPath, bakPath);
    engine.bakFiles.push({ original: originalPath, bak: bakPath });

    // rollback 실행
    engine._rollback();

    // .tmp 파일 정리 확인
    assert.equal(fs.existsSync(fakeTmpPath), false);

    // .bak에서 원본 복원 확인
    assert.equal(fs.readFileSync(originalPath, "utf-8"), originalContent);

    // .bak 파일 정리 확인
    assert.equal(fs.existsSync(bakPath), false);
  });

  it("tmpFiles에 등록되었지만 파일이 없는 경우도 안전하게 처리해야 한다", () => {
    const engine = new BWTEngine(testRoot);

    // 파일 없이 경로만 등록 (writeFileSync가 아예 실패한 경우)
    engine.tmpFiles.push(path.join(testRoot, "90_index", "nonexistent.tmp"));

    // rollback이 에러 없이 완료되어야 함
    engine._rollback();
    assert.equal(engine.tmpFiles.length, 0);
  });
});

describe("BWT: _commit 부분 실패 시 복원", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("commit 중 rename 실패 시 이미 커밋된 파일이 .tmp로 복원되어야 한다", () => {
    const engine = new BWTEngine(testRoot);

    // 정상 레코드 1개 생성
    const createResult = engine.execute({
      action: "create",
      sourceRef: "30_topics/commit-test/notes.md",
      content: "커밋 테스트",
      record: {
        scopeType: "topic",
        scopeId: "commit-test",
        type: "note",
        title: "커밋 테스트",
        summary: "요약",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });
    assert.equal(createResult.success, true);

    // 원본 상태 스냅샷
    const originalRecords = fs.readFileSync(
      path.join(testRoot, "90_index", "records.jsonl"), "utf-8"
    );

    // 새 엔진으로 두 번째 create 시도 — commit 단계에서 실패를 유도
    const engine2 = new BWTEngine(testRoot);

    // _commit을 가로채서 두 번째 rename에서 실패하도록 함
    const originalCommit = engine2._commit.bind(engine2);
    let renameCount = 0;
    const originalRename = fs.renameSync;
    engine2._commit = function() {
      renameCount = 0;
      const _renameSync = fs.renameSync;
      fs.renameSync = function(src, dst) {
        renameCount++;
        if (renameCount === 2) {
          fs.renameSync = _renameSync; // 복원
          throw new Error("시뮬레이션: rename 실패");
        }
        return _renameSync(src, dst);
      };
      try {
        originalCommit.call(this);
      } finally {
        fs.renameSync = _renameSync; // 반드시 복원
      }
    };

    const result2 = engine2.execute({
      action: "create",
      sourceRef: "30_topics/commit-fail/notes.md",
      content: "실패할 커밋",
      record: {
        scopeType: "topic",
        scopeId: "commit-fail",
        type: "note",
        title: "실패 테스트",
        summary: "요약",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });

    // 실패 확인
    assert.equal(result2.success, false);

    // .tmp 잔류 없음
    const indexFiles = fs.readdirSync(path.join(testRoot, "90_index"));
    assert.equal(indexFiles.filter(f => f.endsWith(".tmp")).length, 0);

    // .bak 잔류 없음
    assert.equal(indexFiles.filter(f => f.endsWith(".bak")).length, 0);
  });
});

describe("BWT: contentHash 정확성", () => {
  before(() => setupBrain());
  after(() => teardownBrain());

  it("저장된 contentHash가 실제 내용의 해시와 일치해야 한다", () => {
    const content = "해시 검증 테스트 내용입니다.";
    const expectedHash = calculateHashFromString(content);

    const engine = new BWTEngine(testRoot);
    const result = engine.execute({
      action: "create",
      sourceRef: "30_topics/hash/notes.md",
      content: content,
      record: {
        scopeType: "topic",
        scopeId: "hash",
        type: "note",
        title: "해시 테스트",
        summary: "해시 검증",
        tags: ["domain/memory"],
        sourceType: "candidate"
      }
    });

    assert.equal(result.success, true);

    const records = readJsonl(path.join(testRoot, "90_index", "records.jsonl"));
    assert.equal(records[0].contentHash, expectedHash);
  });
});
